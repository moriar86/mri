<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Marli Jump & Run</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #87ceeb;
      touch-action: manipulation;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Responsive Größen
const scale = canvas.width / 400; // Basisskalierung für kleinere Screens
const unit = scale * 10;

// Asset-Pfade
const imageSources = {
  marli: "marli.png",
  knight: "knight.png",
  heart: "heart.png",
  avocado: "Avocado.png",
  burrito: "burrito.png",
  milkshake: "milkshake.png"
};

const images = {};
let loaded = 0;
const toLoad = Object.keys(imageSources).length;

for (let key in imageSources) {
  images[key] = new Image();
  images[key].src = imageSources[key];
  images[key].onload = () => {
    loaded++;
    if (loaded === toLoad) startGame();
  };
}

function startGame() {
  const groundY = canvas.height - unit * 5;
 let marli = {
  x: unit * 5,
  y: groundY - unit * 11.2,
  width: unit * 8,
  height: unit * 11.2,
  dy: 0,
  gravity: 0.6 * scale,
  jumpPower: -12 * scale,
  isJumping: false,
  speed: 5 * scale,
  lives: 3
};

  const enemies = [];
  const foods = [];
  const foodSprites = [images.avocado, images.burrito, images.milkshake];

function spawnEnemy() {
  enemies.push({
    x: canvas.width + Math.random() * 300,
    y: groundY - unit * 9.6,
    width: unit * 8,
    height: unit * 9.6,
    speed: 5 * scale,
    canHit: true,
    active: true
  });
}

function spawnFood() {
  foods.push({
    x: canvas.width + Math.random() * 300,
    y: groundY - unit * 6.4,
    width: unit * 6.4,
    height: unit * 6.4,
    sprite: foodSprites[Math.floor(Math.random() * foodSprites.length)]
  });
}

  document.addEventListener("touchstart", () => {
    if (!marli.isJumping) {
      marli.dy = marli.jumpPower;
      marli.isJumping = true;
    }
  });

  function update() {
    marli.dy += marli.gravity;
    marli.y += marli.dy;

    if (marli.y + marli.height >= groundY) {
      marli.y = groundY - marli.height;
      marli.isJumping = false;
    }

    enemies.forEach((enemy, index) => {
      if (!enemy.active) return;
      enemy.x -= enemy.speed;

      if (enemy.x + enemy.width < 0) {
        enemies.splice(index, 1);
        return;
      }

      const hit =
        marli.x < enemy.x + enemy.width &&
        marli.x + marli.width > enemy.x &&
        marli.y < enemy.y + enemy.height &&
        marli.y + marli.height > enemy.y;

      if (hit) {
        if (marli.dy > 0) {
          enemy.active = false;
        } else if (enemy.canHit) {
          marli.lives--;
          enemy.canHit = false;
          if (marli.lives <= 0) {
            alert("Game Over!");
            resetGame();
          }
        }
      }
    });

    foods.forEach((food, index) => {
      food.x -= marli.speed;
      const collected =
        marli.x < food.x + food.width &&
        marli.x + marli.width > food.x &&
        marli.y < food.y + food.height &&
        marli.y + marli.height > food.y;

      if (collected) {
        if (marli.lives < 3) marli.lives++;
        foods.splice(index, 1);
      }
    });

    if (Math.random() < 0.01) spawnEnemy();
    if (Math.random() < 0.006) spawnFood();

    if (marli.speed < 12 * scale) marli.speed += 0.0005;
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "green";
    ctx.fillRect(0, groundY, canvas.width, unit * 5);

    ctx.drawImage(images.marli, marli.x, marli.y, marli.width, marli.height);

    enemies.forEach(enemy => {
      if (enemy.active)
        ctx.drawImage(images.knight, enemy.x, enemy.y, enemy.width, enemy.height);
    });

    foods.forEach(food => {
      ctx.drawImage(food.sprite, food.x, food.y, food.width, food.height);
    });

    // Herz-Anzeige
    for (let i = 0; i < marli.lives; i++) {
      ctx.drawImage(images.heart, unit * 2 + i * (unit * 4), unit * 2, unit * 3, unit * 3);
    }
  }

  function resetGame() {
    marli.lives = 3;
    marli.speed = 5 * scale;
    enemies.length = 0;
    foods.length = 0;
  }

  function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }

  gameLoop();
}
</script>
</body>
</html>
